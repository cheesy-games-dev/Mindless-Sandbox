<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SpaceWizards.Lidgren.Network</name>
    </assembly>
    <members>
        <member name="T:Lidgren.Network.NamespaceDoc">
            <summary>
            Lidgren Network Library
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetBigInteger">
            <summary>
            Big integer class based on BouncyCastle (http://www.bouncycastle.org) big integer code
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetBitVector">
            <summary>
            Fixed size vector of booleans
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBitVector.Capacity">
            <summary>
            Gets the number of bits/booleans stored in this vector
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.#ctor(System.Int32)">
            <summary>
            NetBitVector constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.IsEmpty">
            <summary>
            Returns true if all bits/booleans are set to zero/false
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.Count">
            <summary>
            Returns the number of bits/booleans set to one/true
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.RotateDown">
            <summary>
            Shift all bits one step down, cycling the first bit to the top
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.GetFirstSetIndex">
            <summary>
            Gets the first (lowest) index set to true
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.Get(System.Int32)">
            <summary>
            Gets the bit/bool at the specified index
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.Set(System.Int32,System.Boolean)">
            <summary>
            Sets or clears the bit/bool at the specified index
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBitVector.Bit(System.Int32)">
            <summary>
            Gets the bit/bool at the specified index
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.Clear">
            <summary>
            Sets all bits/booleans to zero/false
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetBitWriter">
            <summary>
            Helper class for NetBuffer to write/read bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.ReadByte(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read 1-8 bits from a buffer into a byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.ReadByte(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32)">
            <summary>
            Read 1-8 bits from a buffer into a byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.ReadBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Read several bytes from a buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.ReadBytes(System.ReadOnlySpan{System.Byte},System.Int32,System.Span{System.Byte})">
            <summary>
            Read several bytes from a buffer
            </summary>
            <remarks>
            	The amount of bytes read is the length of the <paramref name="destination"/> parameter.
            </remarks>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteByte(System.Byte,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Write 0-8 bits of data to buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteByte(System.Byte,System.Int32,System.Span{System.Byte},System.Int32)">
            <summary>
            Write 0-8 bits of data to buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Write several whole bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteBytes(System.ReadOnlySpan{System.Byte},System.Byte[],System.Int32)">
            <summary>
            Write several whole bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.ReadUInt16(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32)">
            <summary>
            Reads an unsigned 16 bit integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.ReadUInt32(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bits into an UInt32
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteUInt16(System.UInt16,System.Int32,System.Span{System.Byte},System.Int32)">
            <summary>
            Writes an unsigned 16 bit integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteUInt32(System.UInt32,System.Int32,System.Span{System.Byte},System.Int32)">
            <summary>
            Writes the specified number of bits into a byte array
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteUInt64(System.UInt64,System.Int32,System.Span{System.Byte},System.Int32)">
            <summary>
            Writes the specified number of bits into a byte array
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteVariableUInt32(System.Span{System.Byte},System.Int32,System.UInt32)">
            <summary>
            Write Base128 encoded variable sized unsigned integer
            </summary>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.ReadVariableUInt32(System.ReadOnlySpan{System.Byte},System.Int32@)">
            <summary>
            Reads a UInt32 written using WriteUnsignedVarInt(); will increment offset!
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.Zero(System.Span{System.Byte},System.Int32,System.Int32)">
            <summary>
            Zero a number of bits
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetBuffer">
            <summary>
            Base class for NetIncomingMessage and NetOutgoingMessage
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetBuffer.c_overAllocateAmount">
            <summary>
            Number of bytes to overallocate for each message to avoid resizing
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBuffer.Data">
            <summary>
            Gets or sets the internal data buffer.
            </summary>
            <remarks>
            Throws an <see cref="T:Lidgren.Network.NetException"/> if internal <see cref="F:Lidgren.Network.NetBuffer.m_data"/> field is null or if set a null value.
            </remarks>
            <exception cref="T:Lidgren.Network.NetException"/>
        </member>
        <member name="P:Lidgren.Network.NetBuffer.LengthBytes">
            <summary>
            Gets or sets the length of the used portion of the buffer in bytes
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBuffer.LengthBits">
            <summary>
            Gets or sets the length of the used portion of the buffer in bits
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBuffer.Position">
            <summary>
            Gets or sets the read position in the buffer, in bits (not bytes)
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBuffer.PositionInBytes">
            <summary>
            Gets the position in the buffer in bytes; note that the bits of the first returned byte may already have been read - check the Position property to make sure.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekDataBuffer">
            <summary>
            Gets the internal data buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekBoolean">
            <summary>
            Reads a 1-bit Boolean without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekByte">
            <summary>
            Reads a Byte without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekSByte">
            <summary>
            Reads an SByte without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekByte(System.Int32)">
            <summary>
            Reads the specified number of bits into a Byte without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekBytes(System.Span{System.Byte})">
            <summary>
            Reads the specified number of bytes without advancing the read pointer
            </summary>
            <returns>
            	<paramref name="into"/>, for easier usage with <see langword="stackalloc" />.
            </returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekBytes(System.Int32)">
            <summary>
            Reads the specified number of bytes without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bytes without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekInt16">
            <summary>
            Reads an Int16 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekUInt16">
            <summary>
            Reads a UInt16 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekInt32">
            <summary>
            Reads an Int32 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekInt32(System.Int32)">
            <summary>
            Reads the specified number of bits into an Int32 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekUInt32">
            <summary>
            Reads a UInt32 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekUInt32(System.Int32)">
            <summary>
            Reads the specified number of bits into a UInt32 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekUInt64">
            <summary>
            Reads a UInt64 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekInt64">
            <summary>
            Reads an Int64 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekUInt64(System.Int32)">
            <summary>
            Reads the specified number of bits into an UInt64 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekInt64(System.Int32)">
            <summary>
            Reads the specified number of bits into an Int64 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekFloat">
            <summary>
            Reads a 32-bit Single without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekSingle">
            <summary>
            Reads a 32-bit Single without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekDouble">
            <summary>
            Reads a 64-bit Double without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekString">
            <summary>
            Reads a string without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekStringSize">
            <summary>
            Reads the string byte size prefix without advancing the read pointer.
            Take note that this is the size in bytes, not the character length of the string.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadBoolean">
            <summary>
            Reads a boolean value (stored as a single bit) written using Write(bool)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadByte">
            <summary>
            Reads a byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadByte(System.Byte@)">
            <summary>
            Reads a byte and returns true or false for success
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadSByte">
            <summary>
            Reads a signed byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadByte(System.Int32)">
            <summary>
            Reads 1 to 8 bits into a byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadBytes(System.Span{System.Byte})">
            <summary>
            Reads the specified number of bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadBytes(System.Int32)">
            <summary>
            Reads the specified number of bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadBytes(System.Int32,System.Byte[]@)">
            <summary>
            Reads the specified number of bytes and returns true for success
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.TryReadBytes(System.Span{System.Byte})">
            <summary>
            Reads the specified number of bytes and returns true for success
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bytes into a preallocated array
            </summary>
            <param name="into">The destination array</param>
            <param name="offset">The offset where to start writing in the destination array</param>
            <param name="numberOfBytes">The number of bytes to read</param>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadBits(System.Span{System.Byte},System.Int32)">
            <summary>
            Reads the specified number of bits into a preallocated span
            </summary>
            <param name="into">The destination array</param>
            <param name="numberOfBits">The number of bits to read</param>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadBits(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bits into a preallocated array
            </summary>
            <param name="into">The destination array</param>
            <param name="offset">The offset where to start writing in the destination array</param>
            <param name="numberOfBits">The number of bits to read</param>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadInt16">
            <summary>
            Reads a 16 bit signed integer written using Write(Int16)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUInt16">
            <summary>
            Reads a 16 bit unsigned integer written using Write(UInt16)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadInt32">
            <summary>
            Reads a 32 bit signed integer written using Write(Int32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadInt32(System.Int32@)">
            <summary>
            Reads a 32 bit signed integer written using Write(Int32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadInt32(System.Int32)">
            <summary>
            Reads a signed integer stored in 1 to 32 bits, written using Write(Int32, Int32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUInt32">
            <summary>
            Reads an 32 bit unsigned integer written using Write(UInt32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUInt32(System.UInt32@)">
            <summary>
            Reads an 32 bit unsigned integer written using Write(UInt32) and returns true for success
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUInt32(System.Int32)">
            <summary>
            Reads an unsigned integer stored in 1 to 32 bits, written using Write(UInt32, Int32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUInt64">
            <summary>
            Reads a 64 bit unsigned integer written using Write(UInt64)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadInt64">
            <summary>
            Reads a 64 bit signed integer written using Write(Int64)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUInt64(System.Int32)">
            <summary>
            Reads an unsigned integer stored in 1 to 64 bits, written using Write(UInt64, Int32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadInt64(System.Int32)">
            <summary>
            Reads a signed integer stored in 1 to 64 bits, written using Write(Int64, Int32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadFloat">
            <summary>
            Reads a 32 bit floating point value written using Write(Single)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadSingle">
            <summary>
            Reads a 32 bit floating point value written using Write(Single)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadSingle(System.Single@)">
            <summary>
            Reads a 32 bit floating point value written using Write(Single)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadDouble">
            <summary>
            Reads a 64 bit floating point value written using Write(Double)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadVariableUInt32">
            <summary>
            Reads a variable sized UInt32 written using WriteVariableUInt32()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadVariableUInt32(System.UInt32@)">
            <summary>
            Reads a variable sized UInt32 written using WriteVariableUInt32() and returns true for success
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadVariableInt32">
            <summary>
            Reads a variable sized Int32 written using WriteVariableInt32()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadVariableInt64">
            <summary>
            Reads a variable sized Int64 written using WriteVariableInt64()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadVariableUInt64">
            <summary>
            Reads a variable sized UInt32 written using WriteVariableInt64()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadSignedSingle(System.Int32)">
            <summary>
            Reads a 32 bit floating point value written using WriteSignedSingle()
            </summary>
            <param name="numberOfBits">The number of bits used when writing the value</param>
            <returns>A floating point value larger or equal to -1 and smaller or equal to 1</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUnitSingle(System.Int32)">
            <summary>
            Reads a 32 bit floating point value written using WriteUnitSingle()
            </summary>
            <param name="numberOfBits">The number of bits used when writing the value</param>
            <returns>A floating point value larger or equal to 0 and smaller or equal to 1</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadRangedSingle(System.Single,System.Single,System.Int32)">
            <summary>
            Reads a 32 bit floating point value written using WriteRangedSingle()
            </summary>
            <param name="min">The minimum value used when writing the value</param>
            <param name="max">The maximum value used when writing the value</param>
            <param name="numberOfBits">The number of bits used when writing the value</param>
            <returns>A floating point value larger or equal to MIN and smaller or equal to MAX</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadRangedInteger(System.Int32,System.Int32)">
            <summary>
            Reads a 32 bit integer value written using WriteRangedInteger()
            </summary>
            <param name="min">The minimum value used when writing the value</param>
            <param name="max">The maximum value used when writing the value</param>
            <returns>A signed integer value larger or equal to MIN and smaller or equal to MAX</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadRangedInteger(System.Int64,System.Int64)">
            <summary>
            Reads a 64 bit integer value written using WriteRangedInteger() (64 version)
            </summary>
            <param name="min">The minimum value used when writing the value</param>
            <param name="max">The maximum value used when writing the value</param>
            <returns>A signed integer value larger or equal to MIN and smaller or equal to MAX</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadString">
            <summary>
            Reads a string written using Write(string)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadString(System.String@)">
            <summary>
            Reads a string written using Write(string) and returns true for success
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadTime(Lidgren.Network.NetConnection,System.Boolean)">
            <summary>
            Reads a value, in local time comparable to NetTime.Now, written using WriteTime() for the connection supplied
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadIPEndPoint">
            <summary>
            Reads a stored IPv4 endpoint description
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.SkipPadBits">
            <summary>
            Pads data with enough bits to reach a full byte. Decreases cpu usage for subsequent byte writes.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadPadBits">
            <summary>
            Pads data with enough bits to reach a full byte. Decreases cpu usage for subsequent byte writes.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.SkipPadBits(System.Int32)">
            <summary>
            Pads data with the specified number of bits.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadAllFields(System.Object)">
            <summary>
            Reads all public and private declared instance fields of the object in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadAllFields(System.Object,System.Reflection.BindingFlags)">
            <summary>
            Reads all fields with the specified binding of the object in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadAllProperties(System.Object)">
            <summary>
            Reads all public and private declared instance fields of the object in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadAllProperties(System.Object,System.Reflection.BindingFlags)">
            <summary>
            Reads all fields with the specified binding of the object in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.EnsureBufferSize(System.Int32)">
            <summary>
            Ensures the buffer can hold this number of bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.InternalEnsureBufferSize(System.Int32)">
            <summary>
            Ensures the buffer can hold this number of bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Boolean)">
            <summary>
            Writes a boolean value using 1 bit
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Byte)">
            <summary>
            Write a byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAt(System.Int32,System.Byte)">
            <summary>
            Writes a byte at a given offset in the buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.SByte)">
            <summary>
            Writes a signed byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Byte,System.Int32)">
            <summary>
            Writes 1 to 8 bits of a byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Byte[])">
            <summary>
            Writes all bytes in an array
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes all bytes in a span
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the specified number of bytes from an array
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.UInt16)">
            <summary>
            Writes an unsigned 16 bit integer
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAt(System.Int32,System.UInt16)">
            <summary>
            Writes a 16 bit unsigned integer at a given offset in the buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.UInt16,System.Int32)">
            <summary>
            Writes an unsigned integer using 1 to 16 bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Int16)">
            <summary>
            Writes a signed 16 bit integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAt(System.Int32,System.Int16)">
            <summary>
            Writes a 16 bit signed integer at a given offset in the buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Int32)">
            <summary>
            Writes a 32 bit signed integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAt(System.Int32,System.Int32)">
            <summary>
            Writes a 32 bit signed integer at a given offset in the buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.UInt32)">
            <summary>
            Writes a 32 bit unsigned integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAt(System.Int32,System.UInt32)">
            <summary>
            Writes a 32 bit unsigned integer at a given offset in the buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.UInt32,System.Int32)">
            <summary>
            Writes a 32 bit signed integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Int32,System.Int32)">
            <summary>
            Writes a signed integer using 1 to 32 bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.UInt64)">
            <summary>
            Writes a 64 bit unsigned integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAt(System.Int32,System.UInt64)">
            <summary>
            Writes a 64 bit unsigned integer at a given offset in the buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.UInt64,System.Int32)">
            <summary>
            Writes an unsigned integer using 1 to 64 bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Int64)">
            <summary>
            Writes a 64 bit signed integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Int64,System.Int32)">
            <summary>
            Writes a signed integer using 1 to 64 bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Single)">
            <summary>
            Writes a 32 bit floating point value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Double)">
            <summary>
            Writes a 64 bit floating point value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteVariableUInt32(System.UInt32)">
            <summary>
            Write Base128 encoded variable sized unsigned integer of up to 32 bits
            </summary>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteVariableInt32(System.Int32)">
            <summary>
            Write Base128 encoded variable sized signed integer of up to 32 bits
            </summary>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteVariableInt64(System.Int64)">
            <summary>
            Write Base128 encoded variable sized signed integer of up to 64 bits
            </summary>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteVariableUInt64(System.UInt64)">
            <summary>
            Write Base128 encoded variable sized unsigned integer of up to 64 bits
            </summary>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteSignedSingle(System.Single,System.Int32)">
            <summary>
            Compress (lossy) a float in the range -1..1 using numberOfBits bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteUnitSingle(System.Single,System.Int32)">
            <summary>
            Compress (lossy) a float in the range 0..1 using numberOfBits bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteRangedSingle(System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Compress a float within a specified range using a certain number of bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteRangedInteger(System.Int32,System.Int32,System.Int32)">
            <summary>
            Writes an integer with the least amount of bits need for the specified range
            Returns number of bits written
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteRangedInteger(System.Int64,System.Int64,System.Int64)">
            <summary>
            Writes an integer with the least amount of bits need for the specified range
            Returns number of bits written
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.String)">
            <summary>
            Write a string
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Net.IPEndPoint)">
            <summary>
            Writes an endpoint description
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteTime(System.Boolean)">
            <summary>
            Writes the current local time to a message; readable (and convertable to local time) by the remote host using ReadTime()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteTime(System.Double,System.Boolean)">
            <summary>
            Writes a local timestamp to a message; readable (and convertable to local time) by the remote host using ReadTime()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WritePadBits">
            <summary>
            Pads data with enough bits to reach a full byte. Decreases cpu usage for subsequent byte writes.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WritePadBits(System.Int32)">
            <summary>
            Pads data with the specified number of bits.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(Lidgren.Network.NetBuffer)">
            <summary>
            Append all the bits of message to this message
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Zero(System.Int32)">
            <summary>
            Writes a number of zeroed bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAllFields(System.Object)">
            <summary>
            Writes all public and private declared instance fields of the object in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAllFields(System.Object,System.Reflection.BindingFlags)">
            <summary>
            Writes all fields with specified binding in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAllProperties(System.Object)">
            <summary>
            Writes all public and private declared instance properties of the object in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAllProperties(System.Object,System.Reflection.BindingFlags)">
            <summary>
            Writes all properties with specified binding in alphabetical order using reflection
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetClient">
            <summary>
            Specialized version of NetPeer used for a "client" connection. It does not accept any incoming connections and maintains a ServerConnection property
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetClient.ServerConnection">
            <summary>
            Gets the connection to the server, if any
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetClient.ConnectionStatus">
            <summary>
            Gets the connection status of the server connection (or NetConnectionStatus.Disconnected if no connection)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetClient.#ctor(Lidgren.Network.NetPeerConfiguration)">
            <summary>
            NetClient constructor
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:Lidgren.Network.NetClient.Connect(System.Net.IPEndPoint,Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Connect to a remote server
            </summary>
            <param name="remoteEndPoint">The remote endpoint to connect to</param>
            <param name="hailMessage">The hail message to pass</param>
            <returns>server connection, or null if already connected</returns>
        </member>
        <member name="M:Lidgren.Network.NetClient.Disconnect(System.String)">
            <summary>
            Disconnect from server
            </summary>
            <param name="byeMessage">reason for disconnect</param>
        </member>
        <member name="M:Lidgren.Network.NetClient.SendMessage(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetDeliveryMethod)">
            <summary>
            Sends message to server
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetClient.SendMessage(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetDeliveryMethod,System.Int32)">
            <summary>
            Sends message to server
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetClient.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetConnection">
            <summary>
            Represents a connection to a remote peer
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.Tag">
            <summary>
            Gets or sets the application defined object containing data about the connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.Peer">
            <summary>
            Gets the peer which holds this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.Status">
            <summary>
            Gets the current status of the connection (synced to the last status message read)
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.Statistics">
            <summary>
            Gets various statistics for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.RemoteEndPoint">
            <summary>
            Gets the remote endpoint for the connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.RemoteUniqueIdentifier">
            <summary>
            Gets the unique identifier of the remote NetPeer for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.LocalHailMessage">
            <summary>
            Gets the local hail message that was sent as part of the handshake, if any
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.MutateEndPoint(System.Net.IPEndPoint)">
            <summary>
            Change the internal endpoint to this new one. Used when, during handshake, a switch in port is detected (due to NAT)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.SendMessage(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetDeliveryMethod,System.Int32)">
            <summary>
            Send a message to this remote connection
            </summary>
            <param name="msg">The message to send</param>
            <param name="method">How to deliver the message</param>
            <param name="sequenceChannel">Sequence channel within the delivery method</param>
        </member>
        <member name="M:Lidgren.Network.NetConnection.GetSendQueueInfo(Lidgren.Network.NetDeliveryMethod,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Zero windowSize indicates that the channel is not yet instantiated (used)
            Negative freeWindowSlots means this amount of messages are currently queued but delayed due to closed window
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.CanSendImmediately(Lidgren.Network.NetDeliveryMethod,System.Int32)">
            <summary>
            Test whether the client window allows a message to be sent immediately.
            </summary>
            <param name="method">The delivery method that a message would be sent on.</param>
            <param name="sequenceChannel">The sequence channel that a message would be sent on.</param>
            <remarks>
            If this returns false, messages may still be queued but will not be sent out
            until the client window allows it.
            </remarks>
        </member>
        <member name="M:Lidgren.Network.NetConnection.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.RemoteHailMessage">
            <summary>
            The message that the remote part specified via Connect() or Approve() - can be null.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.Approve">
            <summary>
            Approves this connection; sending a connection response to the remote host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.Approve(Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Approves this connection; sending a connection response to the remote host
            </summary>
            <param name="localHail">The local hail message that will be set as RemoteHailMessage on the remote host</param>
        </member>
        <member name="M:Lidgren.Network.NetConnection.Deny">
            <summary>
            Denies this connection; disconnecting it
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.Deny(System.String)">
            <summary>
            Denies this connection; disconnecting it
            </summary>
            <param name="reason">The stated reason for the disconnect, readable as a string in the StatusChanged message on the remote host</param>
        </member>
        <member name="M:Lidgren.Network.NetConnection.Disconnect(System.String)">
            <summary>
            Disconnect from the remote peer
            </summary>
            <param name="byeMessage">the message to send with the disconnect message</param>
        </member>
        <member name="M:Lidgren.Network.NetConnection.Disconnect(System.String,System.Boolean)">
            <summary>
            Disconnect from the remote peer
            </summary>
            <param name="byeMessage">the message to send with the disconnect message</param>
            <param name="sendBye">If false, the remote peer will not be told about the disconnect and will be left in the dark. It will continue to try to communicate with this peer which may cause log spam with warnings.</param>
        </member>
        <member name="P:Lidgren.Network.NetConnection.AverageRoundtripTime">
            <summary>
            Gets the current average roundtrip time in seconds
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.RemoteTimeOffset">
            <summary>
            Time offset between this peer and the remote peer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.GetLocalTime(System.Double)">
            <summary>
            Gets local time value comparable to NetTime.Now from a remote value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.GetRemoteTime(System.Double)">
            <summary>
            Gets the remote time value for a local time value produced by NetTime.Now
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.CurrentMTU">
            <summary>
            Gets the current MTU in bytes. If <see cref="P:Lidgren.Network.NetPeerConfiguration.AutoExpandMTU"/> is false,
            this will be <see cref="P:Lidgren.Network.NetPeerConfiguration.MaximumTransmissionUnit"/> or <see cref="P:Lidgren.Network.NetPeerConfiguration.MaximumTransmissionUnitV6"/>.
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetConnectionStatistics">
            <summary>
            Statistics for a NetConnection instance
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.SentPackets">
            <summary>
            Gets the number of sent packets for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.ReceivedPackets">
            <summary>
            Gets the number of received packets for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.SentBytes">
            <summary>
            Gets the number of sent bytes for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.ReceivedBytes">
            <summary>
            Gets the number of received bytes for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.SentMessages">
            <summary>
            Gets the number of sent messages for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.ReceivedMessages">
            <summary>
            Gets the number of received messages for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.ResentMessages">
            <summary>
            Gets the number of resent reliable messages for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.ResentMessagesDueToHole">
            <summary>
            Gets the number of resent reliable messages because of holes in acks for this connection.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.ResentMessagesDueToDelay">
            <summary>
            Gets the number of resent reliable messages because of delays in acks for this connection.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.DroppedMessages">
            <summary>
            Gets the number of dropped messages for this connection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnectionStatistics.GetWithheldMessages">
            <summary>
            Calculates the number of withheld messages for this connection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnectionStatistics.CalculateUnsentAndStoredMessages(System.Int32@,System.Int32@)">
            <summary>
            Calculates the number of unsent and stored messages for this connection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnectionStatistics.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetConnectionStatus">
            <summary>
            Status for a NetConnection instance
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.None">
            <summary>
            No connection, or attempt, in place
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.InitiatedConnect">
            <summary>
            Connect has been sent; waiting for ConnectResponse
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.ReceivedInitiation">
            <summary>
            Connect was received, but ConnectResponse hasn't been sent yet
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.RespondedAwaitingApproval">
            <summary>
            Connect was received and ApprovalMessage released to the application; awaiting Approve() or Deny()
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.RespondedConnect">
            <summary>
            Connect was received and ConnectResponse has been sent; waiting for ConnectionEstablished
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.Connected">
            <summary>
            Connected
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.Disconnecting">
            <summary>
            In the process of disconnecting
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.Disconnected">
            <summary>
            Disconnected
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetConstants">
            <summary>
            All the constants used when compiling the library
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConstants.NumSequencedChannels">
            <summary>
            Number of channels which needs a sequence number to work
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConstants.NumReliableChannels">
            <summary>
            Number of reliable channels
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetDeliveryMethod">
            <summary>
            How the library deals with resends and handling of late messages
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetDeliveryMethod.Unknown">
            <summary>
            Indicates an error
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetDeliveryMethod.Unreliable">
            <summary>
            Unreliable, unordered delivery
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetDeliveryMethod.UnreliableSequenced">
            <summary>
            Unreliable delivery, but automatically dropping late messages
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetDeliveryMethod.ReliableUnordered">
            <summary>
            Reliable delivery, but unordered
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetDeliveryMethod.ReliableSequenced">
            <summary>
            Reliable delivery, except for late messages which are dropped
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetDeliveryMethod.ReliableOrdered">
            <summary>
            Reliable, ordered delivery
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetException">
            <summary>
            Exception thrown in the Lidgren Network Library
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetException.#ctor">
            <summary>
            NetException constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetException.#ctor(System.String)">
            <summary>
            NetException constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetException.#ctor(System.String,System.Exception)">
            <summary>
            NetException constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetException.Assert(System.Boolean,System.String)">
            <summary>
            Throws an exception, in DEBUG only, if first parameter is false
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetException.Assert(System.Boolean)">
            <summary>
            Throws an exception, in DEBUG only, if first parameter is false
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetIncomingMessage">
            <summary>
            Incoming message either sent from a remote peer or generated within the library
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetIncomingMessage.MessageType">
            <summary>
            Gets the type of this incoming message
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetIncomingMessage.DeliveryMethod">
            <summary>
            Gets the delivery method this message was sent with (if user data)
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetIncomingMessage.SequenceChannel">
            <summary>
            Gets the sequence channel this message was sent with (if user data)
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetIncomingMessage.SenderEndPoint">
            <summary>
            endpoint of sender, if any
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetIncomingMessage.SenderConnection">
            <summary>
            NetConnection of sender, if any
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetIncomingMessage.ReceiveTime">
            <summary>
            What local time the message was received from the network
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetIncomingMessage.ReadTime(System.Boolean)">
            <summary>
            Reads a value, in local time comparable to NetTime.Now, written using WriteTime()
            Must have a connected sender
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetIncomingMessage.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetIncomingMessageType">
            <summary>
            The type of a NetIncomingMessage
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.Error">
            <summary>
            Error; this value should never appear
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.StatusChanged">
            <summary>
            Status for a connection changed
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.UnconnectedData">
            <summary>
            Data sent using SendUnconnectedMessage
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.ConnectionApproval">
            <summary>
            Connection approval is needed
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.Data">
            <summary>
            Application data
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.Receipt">
            <summary>
            Receipt of delivery
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.DiscoveryRequest">
            <summary>
            Discovery request for a response
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.DiscoveryResponse">
            <summary>
            Discovery response to a request
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.VerboseDebugMessage">
            <summary>
            Verbose debug message
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.DebugMessage">
            <summary>
            Debug message
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.WarningMessage">
            <summary>
            Warning message
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.ErrorMessage">
            <summary>
            Error message
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.NatIntroductionSuccess">
            <summary>
            NAT introduction was successful
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.ConnectionLatencyUpdated">
            <summary>
            A roundtrip was measured and NetConnection.AverageRoundtripTime was updated
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetPeer">
            <summary>
            Represents a local peer capable of holding zero, one or more connections to remote peers
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Introduce(System.Net.IPEndPoint,System.Net.IPEndPoint,System.Net.IPEndPoint,System.Net.IPEndPoint,System.String)">
            <summary>
            Send NetIntroduction to hostExternal and clientExternal; introducing client to host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.HandleNatIntroduction(System.Int32)">
            <summary>
            Called when host/client receives a NatIntroduction message from a master server
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.HandleNatPunch(System.Int32,System.Net.IPEndPoint)">
            <summary>
            Called when receiving a NatPunchMessage from a remote endpoint
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Status">
            <summary>
            Gets the NetPeerStatus of the NetPeer
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.MessageReceivedEvent">
            <summary>
            Signalling event which can be waited on to determine when a message is queued for reading.
            Note that there is no guarantee that after the event is signaled the blocked thread will
            find the message in the queue. Other user created threads could be preempted and dequeue
            the message before the waiting thread wakes up.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.UniqueIdentifier">
            <summary>
            Gets a unique identifier for this NetPeer based on Mac address and ip/port. Note! Not available until Start() has been called!
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Port">
            <summary>
            Gets the port number this NetPeer is listening and sending on, if Start() has been called
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.UPnP">
            <summary>
            Returns an UPnP object if enabled in the NetPeerConfiguration
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Tag">
            <summary>
            Gets or sets the application defined object containing data about the peer
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Connections">
            <summary>
            Gets a copy of the list of connections
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.ConnectionsCount">
            <summary>
            Gets the number of active connections
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Statistics">
            <summary>
            Statistics on this NetPeer since it was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Configuration">
            <summary>
            Gets the configuration used to instanciate this NetPeer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.#ctor(Lidgren.Network.NetPeerConfiguration)">
            <summary>
            NetPeer constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Start">
            <summary>
            Binds to socket and spawns the networking thread
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.GetConnection(System.Net.IPEndPoint)">
            <summary>
            Get the connection, if any, for a certain remote endpoint
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.WaitMessage(System.Int32)">
            <summary>
            Read a pending message from any connection, blocking up to maxMillis if needed
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.ReadMessage">
            <summary>
            Read a pending message from any connection, if any
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.ReadMessage(Lidgren.Network.NetIncomingMessage@)">
            <summary>
            Reads a pending message from any connection, if any.
            Returns true if message was read, otherwise false.
            </summary>
            <returns>True, if message was read.</returns>
        </member>
        <member name="M:Lidgren.Network.NetPeer.ReadMessages(System.Collections.Generic.IList{Lidgren.Network.NetIncomingMessage})">
            <summary>
            Read a pending message from any connection, if any
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Connect(System.String,System.Int32)">
            <summary>
            Create a connection to a remote endpoint
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Connect(System.String,System.Int32,Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Create a connection to a remote endpoint
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Connect(System.Net.IPEndPoint)">
            <summary>
            Create a connection to a remote endpoint
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Connect(System.Net.IPEndPoint,Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Create a connection to a remote endpoint
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.RawSend(System.Byte[],System.Int32,System.Int32,System.Net.IPEndPoint)">
            <summary>
            Send raw bytes; only used for debugging
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.ThrowOrLog(System.String)">
            <summary>
            In DEBUG, throws an exception, in RELEASE logs an error message
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Shutdown(System.String)">
            <summary>
            Disconnects all active connections and closes the socket
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.DiscoverLocalPeers(System.Int32)">
            <summary>
            Emit a discovery signal to all hosts on your subnet
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.DiscoverKnownPeer(System.String,System.Int32)">
            <summary>
            Emit a discovery signal to a single known host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.DiscoverKnownPeer(System.Net.IPEndPoint)">
            <summary>
            Emit a discovery signal to a single known host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendDiscoveryResponse(Lidgren.Network.NetOutgoingMessage,System.Net.IPEndPoint)">
            <summary>
            Send a discovery response message
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Socket">
            <summary>
            Gets the socket, if Start() has been called
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.RegisterReceivedCallback(System.Threading.SendOrPostCallback,System.Threading.SynchronizationContext)">
            <summary>
            Call this to register a callback for when a new message arrives
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.UnregisterReceivedCallback(System.Threading.SendOrPostCallback)">
            <summary>
            Call this to unregister a callback, but remember to do it in the same synchronization context!
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.FlushSendQueue">
            <summary>
            If NetPeerConfiguration.AutoFlushSendQueue() is false; you need to call this to send all messages queued using SendMessage()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.CreateMessage">
            <summary>
            Creates a new message for sending
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.CreateMessage(System.String)">
            <summary>
            Creates a new message for sending and writes the provided string to it
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.CreateMessage(System.Int32)">
            <summary>
            Creates a new message for sending
            </summary>
            <param name="initialCapacity">initial capacity in bytes</param>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Recycle(Lidgren.Network.NetIncomingMessage)">
            <summary>
            Recycles a NetIncomingMessage instance for reuse; taking pressure off the garbage collector
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Recycle(System.Collections.Generic.IEnumerable{Lidgren.Network.NetIncomingMessage})">
            <summary>
            Recycles a list of NetIncomingMessage instances for reuse; taking pressure off the garbage collector
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.CreateIncomingMessage(Lidgren.Network.NetIncomingMessageType,System.String)">
            <summary>
            Creates an incoming message with the required capacity for releasing to the application
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendMessage(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetConnection,Lidgren.Network.NetDeliveryMethod)">
            <summary>
            Send a message to a specific connection
            </summary>
            <param name="msg">The message to send</param>
            <param name="recipient">The recipient connection</param>
            <param name="method">How to deliver the message</param>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendMessage(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetConnection,Lidgren.Network.NetDeliveryMethod,System.Int32)">
            <summary>
            Send a message to a specific connection
            </summary>
            <param name="msg">The message to send</param>
            <param name="recipient">The recipient connection</param>
            <param name="method">How to deliver the message</param>
            <param name="sequenceChannel">Sequence channel within the delivery method</param>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendMessage(Lidgren.Network.NetOutgoingMessage,System.Collections.Generic.IList{Lidgren.Network.NetConnection},Lidgren.Network.NetDeliveryMethod,System.Int32)">
            <summary>
            Send a message to a list of connections
            </summary>
            <param name="msg">The message to send</param>
            <param name="recipients">The list of recipients to send to</param>
            <param name="method">How to deliver the message</param>
            <param name="sequenceChannel">Sequence channel within the delivery method</param>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendUnconnectedMessage(Lidgren.Network.NetOutgoingMessage,System.String,System.Int32)">
            <summary>
            Send a message to an unconnected host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendUnconnectedMessage(Lidgren.Network.NetOutgoingMessage,System.Net.IPEndPoint)">
            <summary>
            Send a message to an unconnected host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendUnconnectedMessage(Lidgren.Network.NetOutgoingMessage,System.Collections.Generic.IList{System.Net.IPEndPoint})">
            <summary>
            Send a message to an unconnected host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendUnconnectedToSelf(Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Send a message to this exact same netpeer (loopback)
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetOutgoingMessage">
            <summary>
            Outgoing message used to send data to remote peer(s)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetOutgoingMessage.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetPeerConfiguration">
            <summary>
            Partly immutable after NetPeer has been initialized
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetPeerConfiguration.kDefaultMTU">
            <summary>
            Default MTU value for IPv4 connections, in bytes.
            </summary>
            <remarks>
            <para>
            Note that lidgren headers (5 bytes) are not included here; since it's part of the "mtu payload".
            </para>
            </remarks>
        </member>
        <member name="F:Lidgren.Network.NetPeerConfiguration.kDefaultMTUV6">
            <summary>
            Default MTU value for IPv6 connections, in bytes.
            </summary>
            <remarks>
            Note that lidgren headers (5 bytes) are not included here; since it's part of the "mtu payload"
            </remarks>
        </member>
        <member name="M:Lidgren.Network.NetPeerConfiguration.#ctor(System.String)">
            <summary>
            NetPeerConfiguration constructor
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.AppIdentifier">
            <summary>
            Gets the identifier of this application; the library can only connect to matching app identifier peers
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerConfiguration.EnableMessageType(Lidgren.Network.NetIncomingMessageType)">
            <summary>
            Enables receiving of the specified type of message
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerConfiguration.DisableMessageType(Lidgren.Network.NetIncomingMessageType)">
            <summary>
            Disables receiving of the specified type of message
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerConfiguration.SetMessageTypeEnabled(Lidgren.Network.NetIncomingMessageType,System.Boolean)">
            <summary>
            Enables or disables receiving of the specified type of message
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerConfiguration.IsMessageTypeEnabled(Lidgren.Network.NetIncomingMessageType)">
            <summary>
            Gets if receiving of the specified type of message is enabled
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.UnreliableSizeBehaviour">
            <summary>
            Gets or sets the behaviour of unreliable sends above MTU
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.NetworkThreadName">
            <summary>
            Gets or sets the name of the library network thread. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.MaximumConnections">
            <summary>
            Gets or sets the maximum amount of connections this peer can hold. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.MaximumTransmissionUnit">
            <summary>
            Gets or sets the maximum amount of bytes to send in a single packet for IPv4 connections, excluding IPv4 and UDP headers.
            Cannot be changed once NetPeer is initialized.
            </summary>
            <seealso cref="P:Lidgren.Network.NetPeerConfiguration.MaximumTransmissionUnitV6"/>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.MaximumTransmissionUnitV6">
            <summary>
            Gets or sets the maximum amount of bytes to send in a single packet for IPv6 connections, excluding IPv6 and UDP headers.
            Cannot be changed once NetPeer is initialized.
            </summary>
            <seealso cref="P:Lidgren.Network.NetPeerConfiguration.MaximumTransmissionUnit"/>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.DefaultOutgoingMessageCapacity">
            <summary>
            Gets or sets the default capacity in bytes when NetPeer.CreateMessage() is called without argument
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.PingInterval">
            <summary>
            Gets or sets the time between latency calculating pings
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.UseMessageRecycling">
            <summary>
            Gets or sets if the library should recycling messages to avoid excessive garbage collection. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.RecycledCacheMaxCount">
            <summary>
            Gets or sets the maximum number of incoming/outgoing messages to keep in the recycle cache.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.ConnectionTimeout">
            <summary>
            Gets or sets the number of seconds timeout will be postponed on a successful ping/pong
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.EnableUPnP">
            <summary>
            Enables UPnP support; enabling port forwarding and getting external ip
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.AutoFlushSendQueue">
            <summary>
            Enables or disables automatic flushing of the send queue. If disabled, you must manully call NetPeer.FlushSendQueue() to flush sent messages to network.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SuppressUnreliableUnorderedAcks">
            <summary>
            If true, will not send acks for unreliable unordered messages. This will save bandwidth, but disable flow control and duplicate detection for this type of messages.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.LocalAddress">
            <summary>
            Gets or sets the local ip address to bind to. Defaults to IPAddress.Any. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.DualStack">
            <summary>
            Gets or sets a value indicating whether the library should use IPv6 dual stack mode.
            If you enable this you should make sure that the <see cref="P:Lidgren.Network.NetPeerConfiguration.LocalAddress"/> is an IPv6 address.
            Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.BroadcastAddress">
            <summary>
            Gets or sets the local broadcast address to use when broadcasting
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.Port">
            <summary>
            Gets or sets the local port to bind to. Defaults to 0. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.ReceiveBufferSize">
            <summary>
            Gets or sets the size in bytes of the receiving buffer. Defaults to 131071 bytes. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SendBufferSize">
            <summary>
            Gets or sets the size in bytes of the sending buffer. Defaults to 131071 bytes. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.AcceptIncomingConnections">
            <summary>
            Gets or sets if the NetPeer should accept incoming connections. This is automatically set to true in NetServer and false in NetClient.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.ResendHandshakeInterval">
            <summary>
            Gets or sets the number of seconds between handshake attempts
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.MaximumHandshakeAttempts">
            <summary>
            Gets or sets the maximum number of handshake attempts before failing to connect
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.AutoExpandMTU">
            <summary>
            Gets or sets if the NetPeer should send large messages to try to expand the maximum transmission unit size
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.ExpandMTUFrequency">
            <summary>
            Gets or sets how often to send large messages to expand MTU if AutoExpandMTU is enabled
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.ExpandMTUFailAttempts">
            <summary>
            Gets or sets the number of failed expand mtu attempts to perform before setting final MTU
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SimulatedLoss">
            <summary>
            Gets or sets the simulated amount of sent packets lost from 0.0f to 1.0f
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SimulatedMinimumLatency">
            <summary>
            Gets or sets the minimum simulated amount of one way latency for sent packets in seconds
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SimulatedRandomLatency">
            <summary>
            Gets or sets the simulated added random amount of one way latency for sent packets in seconds
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SimulatedAverageLatency">
            <summary>
            Gets the average simulated one way latency in seconds
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SimulatedDuplicatesChance">
            <summary>
            Gets or sets the simulated amount of duplicated packets from 0.0f to 1.0f
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerConfiguration.Clone">
            <summary>
            Creates a memberwise shallow clone of this configuration
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetUnreliableSizeBehaviour">
            <summary>
            Behaviour of unreliable sends above MTU
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetUnreliableSizeBehaviour.IgnoreMTU">
            <summary>
            Sending an unreliable message will ignore MTU and send everything in a single packet; this is the new default
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetUnreliableSizeBehaviour.NormalFragmentation">
            <summary>
            Old behaviour; use normal fragmentation for unreliable messages - if a fragment is dropped, memory for received fragments are never reclaimed!
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetUnreliableSizeBehaviour.DropAboveMTU">
            <summary>
            Alternate behaviour; just drops unreliable messages above MTU
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetPeerStatistics">
            <summary>
            Statistics for a NetPeer instance
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.SentPackets">
            <summary>
            Gets the number of sent packets since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.ReceivedPackets">
            <summary>
            Gets the number of received packets since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.SentMessages">
            <summary>
            Gets the number of sent messages since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.ReceivedMessages">
            <summary>
            Gets the number of received messages since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.SentBytes">
            <summary>
            Gets the number of sent bytes since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.ReceivedBytes">
            <summary>
            Gets the number of received bytes since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.StorageBytesAllocated">
            <summary>
            Gets the number of bytes allocated (and possibly garbage collected) for message storage
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.BytesInRecyclePool">
            <summary>
            Gets the number of bytes in the recycled pool
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.ResentMessages">
            <summary>
            Gets the number of resent reliable messages since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.ResentMessagesDueToHole">
            <summary>
            Gets the number of resent reliable messages because of holes in acks since the NetPeer was initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.ResentMessagesDueToDelay">
            <summary>
            Gets the number of resent reliable messages because of delays in acks since the NetPeer was initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.DroppedMessages">
            <summary>
            Gets the number of dropped messages since the NetPeer was initialized.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerStatistics.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetPeerStatus">
            <summary>
            Status for a NetPeer instance
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetPeerStatus.NotRunning">
            <summary>
            NetPeer is not running; socket is not bound
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetPeerStatus.Starting">
            <summary>
            NetPeer is in the process of starting up
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetPeerStatus.Running">
            <summary>
            NetPeer is bound to socket and listening for packets
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetPeerStatus.ShutdownRequested">
            <summary>
            Shutdown has been requested and will be executed shortly
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetQueue`1">
            <summary>
            Thread safe (blocking) expanding queue with TryDequeue() and EnqueueFirst()
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetQueue`1.Count">
            <summary>
            Gets the number of items in the queue
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetQueue`1.Capacity">
            <summary>
            Gets the current capacity for the queue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.#ctor(System.Int32)">
            <summary>
            NetQueue constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.Enqueue(`0)">
            <summary>
            Adds an item last/tail of the queue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.Enqueue(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds an item last/tail of the queue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.EnqueueFirst(`0)">
            <summary>
            Places an item first, at the head of the queue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.TryDequeue(`0@)">
            <summary>
            Gets an item from the head of the queue, or returns default(T) if empty
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.TryDrain(System.Collections.Generic.IList{`0})">
            <summary>
            Gets all items from the head of the queue, or returns number of items popped
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.TryPeek(System.Int32)">
            <summary>
            Returns default(T) if queue is empty
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.Contains(`0)">
            <summary>
            Determines whether an item is in the queue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.ToArray">
            <summary>
            Copies the queue items to a new array
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.Clear">
            <summary>
            Removes all objects from the queue
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetRandom">
            <summary>
            NetRandom base class
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetRandom.Instance">
            <summary>
            Get global instance of NetRandom (uses MWCRandom)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.#ctor">
            <summary>
            Constructor with randomized seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.#ctor(System.Int32)">
            <summary>
            Constructor with provided 32 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.Initialize(System.UInt32)">
            <summary>
            (Re)initialize this instance with provided 32 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextUInt32">
            <summary>
            Generates a random value from UInt32.MinValue to UInt32.MaxValue, inclusively
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.Next">
            <summary>
            Generates a random value that is greater or equal than 0 and less than Int32.MaxValue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextInt32">
            <summary>
            Generates a random value greater or equal than 0 and less or equal than Int32.MaxValue (inclusively)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextDouble">
            <summary>
            Returns random value larger or equal to 0.0 and less than 1.0
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.Sample">
            <summary>
            Returns random value is greater or equal than 0.0 and less than 1.0
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextSingle">
            <summary>
            Returns random value is greater or equal than 0.0f and less than 1.0f
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.Next(System.Int32)">
            <summary>
            Returns a random value is greater or equal than 0 and less than maxValue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random value is greater or equal than minValue and less than maxValue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextUInt64">
            <summary>
            Generates a random value between UInt64.MinValue to UInt64.MaxValue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextBool">
            <summary>
            Returns true or false, randomly
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Fills all bytes from offset to offset + length in buffer with random values
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextBytes(System.Byte[])">
            <summary>
            Fill the specified buffer with random values
            </summary>
        </member>
        <member name="T:Lidgren.Network.MWCRandom">
            <summary>
            Multiply With Carry random
            </summary>
        </member>
        <member name="F:Lidgren.Network.MWCRandom.Instance">
            <summary>
            Get global instance of MWCRandom
            </summary>
        </member>
        <member name="M:Lidgren.Network.MWCRandom.#ctor">
            <summary>
            Constructor with randomized seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.MWCRandom.Initialize(System.UInt32)">
            <summary>
            (Re)initialize this instance with provided 32 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.MWCRandom.Initialize(System.UInt64)">
            <summary>
            (Re)initialize this instance with provided 64 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.MWCRandom.NextUInt32">
            <summary>
            Generates a random value from UInt32.MinValue to UInt32.MaxValue, inclusively
            </summary>
        </member>
        <member name="T:Lidgren.Network.XorShiftRandom">
            <summary>
            Xor Shift based random
            </summary>
        </member>
        <member name="F:Lidgren.Network.XorShiftRandom.Instance">
            <summary>
            Get global instance of XorShiftRandom
            </summary>
        </member>
        <member name="M:Lidgren.Network.XorShiftRandom.#ctor">
            <summary>
            Constructor with randomized seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.XorShiftRandom.#ctor(System.UInt64)">
            <summary>
            Constructor with provided 64 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.XorShiftRandom.Initialize(System.UInt32)">
            <summary>
            (Re)initialize this instance with provided 32 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.XorShiftRandom.Initialize(System.UInt64)">
            <summary>
            (Re)initialize this instance with provided 64 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.XorShiftRandom.NextUInt32">
            <summary>
            Generates a random value from UInt32.MinValue to UInt32.MaxValue, inclusively
            </summary>
        </member>
        <member name="T:Lidgren.Network.MersenneTwisterRandom">
            <summary>
            Mersenne Twister based random
            </summary>
        </member>
        <member name="F:Lidgren.Network.MersenneTwisterRandom.Instance">
            <summary>
            Get global instance of MersenneTwisterRandom
            </summary>
        </member>
        <member name="M:Lidgren.Network.MersenneTwisterRandom.#ctor">
            <summary>
            Constructor with randomized seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.MersenneTwisterRandom.#ctor(System.UInt32)">
            <summary>
            Constructor with provided 32 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.MersenneTwisterRandom.Initialize(System.UInt32)">
            <summary>
            (Re)initialize this instance with provided 32 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.MersenneTwisterRandom.NextUInt32">
            <summary>
            Generates a random value from UInt32.MinValue to UInt32.MaxValue, inclusively
            </summary>
        </member>
        <member name="T:Lidgren.Network.CryptoRandom">
            <summary>
            RNGCryptoServiceProvider based random; very slow but cryptographically safe
            </summary>
        </member>
        <member name="F:Lidgren.Network.CryptoRandom.Instance">
            <summary>
            Global instance of CryptoRandom
            </summary>
        </member>
        <member name="M:Lidgren.Network.CryptoRandom.Initialize(System.UInt32)">
            <summary>
            Seed in CryptoRandom does not create deterministic sequences
            </summary>
        </member>
        <member name="M:Lidgren.Network.CryptoRandom.NextUInt32">
            <summary>
            Generates a random value from UInt32.MinValue to UInt32.MaxValue, inclusively
            </summary>
        </member>
        <member name="M:Lidgren.Network.CryptoRandom.NextBytes(System.Byte[])">
            <summary>
            Fill the specified buffer with random values
            </summary>
        </member>
        <member name="M:Lidgren.Network.CryptoRandom.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Fills all bytes from offset to offset + length in buffer with random values
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetRandomSeed">
            <summary>
            Class for generating random seeds
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandomSeed.GetUInt32">
            <summary>
            Generates a 32 bit random seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandomSeed.GetUInt64">
            <summary>
            Generates a 64 bit random seed
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetReliableSenderChannel">
            <summary>
            Sender part of Selective repeat ARQ for a particular NetChannel
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetSendResult">
            <summary>
            Result of a SendMessage call
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetSendResult.FailedNotConnected">
            <summary>
            Message failed to enqueue because there is no connection
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetSendResult.Sent">
            <summary>
            Message was immediately sent
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetSendResult.Queued">
            <summary>
            Message was queued for delivery
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetSendResult.Dropped">
            <summary>
            Message was dropped immediately since too many message were queued
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetServer">
            <summary>
            Specialized version of NetPeer used for "server" peers
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetServer.#ctor(Lidgren.Network.NetPeerConfiguration)">
            <summary>
            NetServer constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetServer.SendToAll(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetDeliveryMethod)">
            <summary>
            Send a message to all connections
            </summary>
            <param name="msg">The message to send</param>
            <param name="method">How to deliver the message</param>
        </member>
        <member name="M:Lidgren.Network.NetServer.SendToAll(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetDeliveryMethod,System.Int32)">
            <summary>
            Send a message to all connections
            </summary>
            <param name="msg">The message to send</param>
            <param name="method">How to deliver the message</param>
            <param name="sequenceChannel">Which sequence channel to use for the message</param>
        </member>
        <member name="M:Lidgren.Network.NetServer.SendToAll(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetConnection,Lidgren.Network.NetDeliveryMethod,System.Int32)">
            <summary>
            Send a message to all connections except one
            </summary>
            <param name="msg">The message to send</param>
            <param name="method">How to deliver the message</param>
            <param name="except">Don't send to this particular connection</param>
            <param name="sequenceChannel">Which sequence channel to use for the message</param>
        </member>
        <member name="M:Lidgren.Network.NetServer.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetSRP">
            <summary>
            Helper methods for implementing SRP authentication
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeMultiplier">
            <summary>
            Compute multiplier (k)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.CreateRandomSalt">
            <summary>
            Create 16 bytes of random salt
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.CreateRandomEphemeral">
            <summary>
            Create 32 bytes of random ephemeral value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputePrivateKey(System.String,System.String,System.ReadOnlySpan{System.Byte})">
            <summary>
            Computer private key (x)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeServerVerifier(System.ReadOnlySpan{System.Byte})">
            <summary>
            Creates a verifier that the server can later use to authenticate users later on (v)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeClientEphemeral(System.ReadOnlySpan{System.Byte})">
            <summary>
            Compute client public ephemeral value (A)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeServerEphemeral(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Compute server ephemeral value (B)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeU(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Compute intermediate value (u)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeServerSessionValue(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Computes the server session value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeClientSessionValue(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Computes the client session value
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetTime">
            <summary>
            Time service
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetTime.ToReadable(System.Double)">
            <summary>
            Given seconds it will output a human friendly readable string (milliseconds if less than 60 seconds)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetTime.SetNow(System.Double)">
            <summary>
            	Sets <see cref="P:Lidgren.Network.NetTime.Now"/> to the current value and track it like normal.
            </summary>
            <remarks>
            	You are basically guaranteed to break everything if you use this after a NetPeer has been initialized.
            </remarks>
        </member>
        <member name="P:Lidgren.Network.NetTime.Now">
            <summary>
            Get number of seconds since the application started
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetUnreliableSenderChannel">
            <summary>
            Sender part of Selective repeat ARQ for a particular NetChannel
            </summary>
        </member>
        <member name="T:Lidgren.Network.UPnPStatus">
            <summary>
            Status of the UPnP capabilities
            </summary>
        </member>
        <member name="F:Lidgren.Network.UPnPStatus.Discovering">
            <summary>
            Still discovering UPnP capabilities
            </summary>
        </member>
        <member name="F:Lidgren.Network.UPnPStatus.NotAvailable">
            <summary>
            UPnP is not available
            </summary>
        </member>
        <member name="F:Lidgren.Network.UPnPStatus.Available">
            <summary>
            UPnP is available and ready to use
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetUPnP">
            <summary>
            UPnP support class
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetUPnP.Status">
            <summary>
            Status of the UPnP capabilities of this NetPeer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUPnP.#ctor(Lidgren.Network.NetPeer)">
            <summary>
            NetUPnP constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUPnP.ForwardPort(System.Int32,System.String,System.Int32,System.String)">
            <summary>
            Add a forwarding rule to the router using UPnP
            </summary>
            <param name="externalPort">The external, WAN facing, port</param>
            <param name="description">A description for the port forwarding rule</param>
            <param name="internalPort">The port on the client machine to send traffic to (defaults to externalPort)</param>
            <param name="proto">The protocol (defaults to UDP, but can be TCP)</param>
        </member>
        <member name="M:Lidgren.Network.NetUPnP.DeleteForwardingRule(System.Int32,System.String)">
            <summary>
            Delete a forwarding rule from the router using UPnP
            </summary>
            <param name="externalPort">The external, 'internet facing', port</param>
            <param name="proto">The protocol (defaults to UDP, but can be TCP)</param>
        </member>
        <member name="M:Lidgren.Network.NetUPnP.GetExternalIP">
            <summary>
            Retrieve the extern ip using UPnP
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetUtility">
            <summary>
            Utility methods
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.GetCachedBroadcastAddress">
            <summary>
            Get a cached copy of <see cref="M:Lidgren.Network.NetUtility.GetBroadcastAddress"/>.
            </summary>
            <remarks>
            This value is cached when this function is first called.
            </remarks>
            <seealso cref="M:Lidgren.Network.NetUtility.GetBroadcastAddress"/>
            <seealso cref="M:Lidgren.Network.NetUtility.GetMyAddress(System.Net.IPAddress@)"/>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ToHexString(System.Int64)">
            <summary>
            Create a hex string from an Int64 value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ToHexString(System.Byte[])">
            <summary>
            Create a hex string from an array of bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ToHexString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a hex string from an array of bytes
            </summary>
            <param name="data">Array containing the bytes to turn into hex.</param>
            <param name="offset">Position in <paramref name="data"/> that the data to convert starts at.</param>
            <param name="length">Amount of bytes of data to convert from <paramref name="offset"/>.</param>
            <remarks>
            </remarks>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ToHexString(System.ReadOnlySpan{System.Byte})">
            <summary>
            Create a hex string from an array of bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.IsLocal(System.Net.IPEndPoint)">
            <summary>
            Returns true if the endpoint supplied is on the same subnet as this host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.IsLocal(System.Net.IPAddress)">
            <summary>
            Returns true if the IPAddress supplied is on the same subnet as this host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.BitsToHoldUInt(System.UInt32)">
            <summary>
            Returns how many bits are necessary to hold a certain number
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.BitsToHoldUInt64(System.UInt64)">
            <summary>
            Returns how many bits are necessary to hold a certain number
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.BytesToHoldBits(System.Int32)">
            <summary>
            Returns how many bytes are required to hold a certain number of bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ToByteArray(System.String)">
            <summary>
            Convert a hexadecimal string to a byte array
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ToHumanReadable(System.Int64)">
            <summary>
            Converts a number of bytes to a shorter, more readable string representation
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.GetWindowSize(Lidgren.Network.NetDeliveryMethod)">
            <summary>
            Gets the window size used internally in the library for a certain delivery method
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.MakeCommaDelimitedList``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>
            Creates a comma delimited string from a lite of items
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ComputeSHAHash(System.Byte[])">
            <summary>
            Compute the SHA-256 hash of an array of data.
            </summary>
            <param name="bytes">An array containing the data to hash.</param>
            <returns>The hash result.</returns>
        </member>
        <member name="M:Lidgren.Network.NetUtility.CopyEndpoint(System.Net.IPEndPoint,System.Net.IPEndPoint)">
            <summary>
            Copies from <paramref name="src"/> to <paramref name="dst"/>. Maps to an IPv6 address
            </summary>
            <param name="src">Source.</param>
            <param name="dst">Destination.</param>
        </member>
        <member name="M:Lidgren.Network.NetUtility.MapToIPv6(System.Net.IPEndPoint)">
            <summary>
            Maps the IPEndPoint object to an IPv6 address. Has allocation
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetUtility.ResolveEndPointCallback">
            <summary>
            Asynchronous callback raised when a remote <see cref="T:System.Net.IPEndPoint"/> has been resolved.
            </summary>
            <remarks>
            This callback is not raised on any particular thread.
            </remarks>
            <param name="endPoint">
            Null if the resolved host name does not exist or does not contain suitable DNS records.
            </param>
        </member>
        <member name="T:Lidgren.Network.NetUtility.ResolveAddressCallback">
            <summary>
            Resolve address callback
            </summary>
            <remarks>
            This callback is not raised on any particular thread.
            </remarks>
            <param name="adr">
            Null if the resolved host name does not exist or does not contain suitable DNS records.
            </param>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ResolveAsync(System.String,System.Int32,Lidgren.Network.NetUtility.ResolveEndPointCallback)">
            <summary>
            Resolve an IP address or hostname into a <see cref="T:System.Net.IPEndPoint"/>. (asynchronous callback version)
            </summary>
            <remarks>
            <para>
            This function can accept host names or direct IP addresses
            (in standard notation, i.e. <c>xxx.xxx.xxx.xxx</c> for IPv4 or <c>xxxx:xxxx:...:xxxx</c> for IPv6).
            If an IP address is given, it is parsed and immediately returned.
            </para>
            <para>
            This is an asynchronous callback version.
            Instead of returning a value directly, <paramref name="callback"/> is called with the result.
            </para>
            </remarks>
            <param name="ipOrHost">IP address or host name string to resolve.</param>
            <param name="port">Port to use on the returned <see cref="T:System.Net.IPEndPoint"/> instance.</param>
            <param name="callback">Callback that is ran when resolution completes.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="ipOrHost"/> is empty.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown if a network error occurs.</exception>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ResolveAsync(System.String,System.Int32,System.Nullable{System.Net.Sockets.AddressFamily},Lidgren.Network.NetUtility.ResolveEndPointCallback)">
            <summary>
            Resolve an IP address or hostname into a <see cref="T:System.Net.IPEndPoint"/>. (asynchronous callback version)
            </summary>
            <remarks>
            <para>
            This function can accept host names or direct IP addresses
            (in standard notation, i.e. <c>xxx.xxx.xxx.xxx</c> for IPv4 or <c>xxxx:xxxx:...:xxxx</c> for IPv6).
            If an IP address is given, it is parsed and immediately returned.
            </para>
            <para>
            This is an asynchronous callback version.
            Instead of returning a value directly, <paramref name="callback"/> is called with the result.
            </para>
            </remarks>
            <param name="ipOrHost">IP address or host name string to resolve.</param>
            <param name="port">Port to use on the returned <see cref="T:System.Net.IPEndPoint"/> instance.</param>
            <param name="allowedFamily">
            If not <see langword="null"/>, only allow the given address family to be returned.
            Otherwise, both IPv4 and IPv6 addresses can be returned.
            </param>
            <param name="callback">Callback that is ran when resolution completes.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="ipOrHost"/> is empty
            OR
            <paramref name="allowedFamily"/> is not null and not one of <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork"/>
            or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6"/>.
            </exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown if a network error occurs.</exception>
        </member>
        <member name="M:Lidgren.Network.NetUtility.Resolve(System.String,System.Int32)">
            <summary>
            Resolve an IP address or hostname into a <see cref="T:System.Net.IPEndPoint"/>.
            </summary>
            <remarks>
            <para>
            This function can accept host names or direct IP addresses
            (in standard notation, i.e. <c>xxx.xxx.xxx.xxx</c> for IPv4 or <c>xxxx:xxxx:...:xxxx</c> for IPv6).
            If an IP address is given, it is parsed and immediately returned.
            </para>
            <para>
            This function is synchronous,
            prefer using <see cref="M:Lidgren.Network.NetUtility.ResolveAsync(System.String,System.Int32)"/>
            to avoid hanging the current thread if the network has to be accessed.
            </para>
            </remarks>
            <param name="ipOrHost">IP address or host name string to resolve.</param>
            <param name="port">Port to use on the returned <see cref="T:System.Net.IPEndPoint"/> instance.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="ipOrHost"/> is empty.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown if a network error occurs.</exception>
            <returns><see langword="null"/> if the given host does not exist.</returns>
        </member>
        <member name="M:Lidgren.Network.NetUtility.Resolve(System.String,System.Int32,System.Nullable{System.Net.Sockets.AddressFamily})">
            <summary>
            Resolve an IP address or hostname into a <see cref="T:System.Net.IPEndPoint"/>.
            </summary>
            <remarks>
            <para>
            This function can accept host names or direct IP addresses
            (in standard notation, i.e. <c>xxx.xxx.xxx.xxx</c> for IPv4 or <c>xxxx:xxxx:...:xxxx</c> for IPv6).
            If an IP address is given, it is parsed and immediately returned.
            </para>
            <para>
            This function is synchronous,
            prefer using <see cref="M:Lidgren.Network.NetUtility.ResolveAsync(System.String,System.Int32)"/>
            to avoid hanging the current thread if the network has to be accessed.
            </para>
            </remarks>
            <param name="ipOrHost">IP address or host name string to resolve.</param>
            <param name="port">Port to use on the returned <see cref="T:System.Net.IPEndPoint"/> instance.</param>
            <param name="allowedFamily">
            If not <see langword="null"/>, only allow the given address family to be returned.
            Otherwise, both IPv4 and IPv6 addresses can be returned.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="ipOrHost"/> is empty
            OR
            <paramref name="allowedFamily"/> is not null and not one of <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork"/>
            or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6"/>.
            </exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown if a network error occurs.</exception>
            <returns><see langword="null"/> if the given host does not exist.</returns>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ResolveAsync(System.String,Lidgren.Network.NetUtility.ResolveAddressCallback)">
            <summary>
            Resolve an IP address or hostname into a <see cref="T:System.Net.IPAddress"/>. (asynchronous callback version)
            </summary>
            <remarks>
            <para>
            This function can accept host names or direct IP addresses
            (in standard notation, i.e. <c>xxx.xxx.xxx.xxx</c> for IPv4 or <c>xxxx:xxxx:...:xxxx</c> for IPv6).
            If an IP address is given, it is parsed and immediately returned.
            </para>
            <para>
            This is an asynchronous callback version.
            Instead of returning a value directly, <paramref name="callback"/> is called with the result.
            </para>
            </remarks>
            <param name="ipOrHost">IP address or host name string to resolve.</param>
            <param name="callback">Callback that is ran when resolution completes.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="ipOrHost"/> is empty.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown if a network error occurs.</exception>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ResolveAsync(System.String,System.Nullable{System.Net.Sockets.AddressFamily},Lidgren.Network.NetUtility.ResolveAddressCallback)">
            <summary>
            Resolve an IP address or hostname into a <see cref="T:System.Net.IPAddress"/>. (asynchronous callback version)
            </summary>
            <remarks>
            <para>
            This function can accept host names or direct IP addresses
            (in standard notation, i.e. <c>xxx.xxx.xxx.xxx</c> for IPv4 or <c>xxxx:xxxx:...:xxxx</c> for IPv6).
            If an IP address is given, it is parsed and immediately returned.
            </para>
            <para>
            This is an asynchronous callback version.
            Instead of returning a value directly, <paramref name="callback"/> is called with the result.
            </para>
            </remarks>
            <param name="ipOrHost">IP address or host name string to resolve.</param>
            <param name="allowedFamily">
            If not <see langword="null"/>, only allow the given address family to be returned.
            Otherwise, both IPv4 and IPv6 addresses can be returned.
            </param>
            <param name="callback">Callback that is ran when resolution completes.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="ipOrHost"/> is empty
            OR
            <paramref name="allowedFamily"/> is not null and not one of <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork"/>
            or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6"/>.
            </exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown if a network error occurs.</exception>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ResolveAsync(System.String,System.Int32)">
            <summary>
            Resolve an IP address or hostname into a <see cref="T:System.Net.IPEndPoint"/>. (asynchronous task version)
            </summary>
            <remarks>
            <para>
            This function can accept host names or direct IP addresses
            (in standard notation, i.e. <c>xxx.xxx.xxx.xxx</c> for IPv4 or <c>xxxx:xxxx:...:xxxx</c> for IPv6).
            If an IP address is given, it is parsed and immediately returned.
            </para>
            </remarks>
            <param name="ipOrHost">IP address or host name string to resolve.</param>
            <param name="port">Port to use on the returned <see cref="T:System.Net.IPEndPoint"/> instance.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="ipOrHost"/> is empty.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown if a network error occurs.</exception>
            <returns><see langword="null"/> if the given host does not exist.</returns>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ResolveAsync(System.String,System.Int32,System.Nullable{System.Net.Sockets.AddressFamily})">
            <summary>
            Resolve an IP address or hostname into a <see cref="T:System.Net.IPEndPoint"/>. (asynchronous task version)
            </summary>
            <remarks>
            <para>
            This function can accept host names or direct IP addresses
            (in standard notation, i.e. <c>xxx.xxx.xxx.xxx</c> for IPv4 or <c>xxxx:xxxx:...:xxxx</c> for IPv6).
            If an IP address is given, it is parsed and immediately returned.
            </para>
            </remarks>
            <param name="ipOrHost">IP address or host name string to resolve.</param>
            <param name="port">Port to use on the returned <see cref="T:System.Net.IPEndPoint"/> instance.</param>
            <param name="allowedFamily">
            If not <see langword="null"/>, only allow the given address family to be returned.
            Otherwise, both IPv4 and IPv6 addresses can be returned.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="ipOrHost"/> is empty
            OR
            <paramref name="allowedFamily"/> is not null and not one of <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork"/>
            or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6"/>.
            </exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown if a network error occurs.</exception>
            <returns><see langword="null"/> if the given host does not exist.</returns>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ResolveAsync(System.String,System.Nullable{System.Net.Sockets.AddressFamily})">
            <summary>
            Resolve an IP address or hostname into a <see cref="T:System.Net.IPAddress"/>. (asynchronous task version)
            </summary>
            <remarks>
            <para>
            This function can accept host names or direct IP addresses
            (in standard notation, i.e. <c>xxx.xxx.xxx.xxx</c> for IPv4 or <c>xxxx:xxxx:...:xxxx</c> for IPv6).
            If an IP address is given, it is parsed and immediately returned.
            </para>
            </remarks>
            <param name="ipOrHost">IP address or host name string to resolve.</param>
            <param name="allowedFamily">
            If not <see langword="null"/>, only allow the given address family to be returned.
            Otherwise, both IPv4 and IPv6 addresses can be returned.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="ipOrHost"/> is empty
            OR
            <paramref name="allowedFamily"/> is not null and not one of <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork"/>
            or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6"/>.
            </exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown if a network error occurs.</exception>
            <returns><see langword="null"/> if the given host does not exist.</returns>
        </member>
        <member name="M:Lidgren.Network.NetUtility.Resolve(System.String)">
            <summary>
            Resolve an IP address or hostname into a <see cref="T:System.Net.IPAddress"/>.
            </summary>
            <remarks>
            <para>
            This function can accept host names or direct IP addresses
            (in standard notation, i.e. <c>xxx.xxx.xxx.xxx</c> for IPv4 or <c>xxxx:xxxx:...:xxxx</c> for IPv6).
            If an IP address is given, it is parsed and immediately returned.
            </para>
            <para>
            This function is synchronous,
            prefer using <see cref="M:Lidgren.Network.NetUtility.ResolveAsync(System.String,System.Int32)"/>
            to avoid hanging the current thread if the network has to be accessed.
            </para>
            </remarks>
            <param name="ipOrHost">IP address or host name string to resolve.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="ipOrHost"/> is empty.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown if a network error occurs.</exception>
            <returns><see langword="null"/> if the given host does not exist.</returns>
        </member>
        <member name="M:Lidgren.Network.NetUtility.Resolve(System.String,System.Nullable{System.Net.Sockets.AddressFamily})">
            <summary>
            Get IPv4 or IPv6 address from notation (xxx.xxx.xxx.xxx or xxxx:xxxx:...:xxxx) or hostname,
            taking in an allowed address family to filter resolved addresses by.
            </summary>
            <remarks>
            If <paramref name="allowedFamily"/> is not null, the address returned will only be of the specified family.
            </remarks>
            <param name="ipOrHost">The hostname or IP address to parse.</param>
            <param name="allowedFamily">If not null, the allowed address family to return.</param>
            <returns>
            A resolved address matching the specified filter if it exists,
            null if no such address exists or a lookup error occured.
            </returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="ipOrHost"/> is null or empty OR
            <paramref name="allowedFamily"/> is not one of null, <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork"/>
            or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6"/>
            </exception>
        </member>
        <member name="M:Lidgren.Network.NetUtility.GetMacAddressBytes">
            <summary>
            If available, returns the bytes of the physical (MAC) address for the first usable network interface
            </summary>
            <seealso cref="M:Lidgren.Network.NetUtility.GetMyAddress(System.Net.IPAddress@)"/>
        </member>
        <member name="M:Lidgren.Network.NetUtility.GetBroadcastAddress">
            <summary>
            Get the IPv4 address for broadcast on the local network.
            </summary>
            <remarks>
            This may return either the IPv4 "limited broadcast" address
            (<see cref="F:System.Net.IPAddress.Broadcast"/>, i.e. <c>255.255.255.255</c>) or a directed broadcast address for the local
            network, e.g. <c>192.168.1.255</c>.
            </remarks>
            <returns>Null if we are unable to detect a suitable network interface.</returns>
            <seealso cref="M:Lidgren.Network.NetUtility.GetCachedBroadcastAddress"/>
            <seealso cref="M:Lidgren.Network.NetUtility.GetMyAddress(System.Net.IPAddress@)"/>
        </member>
        <member name="M:Lidgren.Network.NetUtility.GetMyAddress(System.Net.IPAddress@)">
            <summary>
            Gets our local IPv4 address (not necessarily external) and subnet mask.
            </summary>
            <returns>
            The IP address we have on the local network.
            Null if we are unable to detect a suitable network interface.
            </returns>
            <seealso cref="M:Lidgren.Network.NetUtility.GetBroadcastAddress"/>
            <seealso cref="M:Lidgren.Network.NetUtility.GetMacAddressBytes"/>
        </member>
        <member name="M:Lidgren.Network.NetUtility.Sleep(System.Int32)">
            <summary>
            Pause execution of the current thread for a given amount of milliseconds.
            Equivalent to <see cref="M:System.Threading.Thread.Sleep(System.Int32)"/>.
            </summary>
            <param name="milliseconds">
            The duration, in milliseconds, to sleep for.
            </param>
        </member>
        <member name="M:Lidgren.Network.NetUtility.CreateAddressFromBytes(System.Byte[])">
            <summary>
            Create a <see cref="T:System.Net.IPAddress"/> instance from an array of bytes.
            </summary>
            <param name="bytes">
            An array of bytes describing the IP address.
            </param>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ComputeSHAHash(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compute the SHA-256 hash of an array of data.
            </summary>
            <param name="bytes">Array containing the data to hash.</param>
            <param name="offset">Position in <paramref name="bytes"/> that the data to hash starts at.</param>
            <param name="count">Amount of bytes of data to hash from <paramref name="offset"/>.</param>
            <returns>The computed hash.</returns>
        </member>
        <member name="M:Lidgren.Network.NetUtility.GetPlatformSeed(System.Int32)">
            <summary>
            Get a seed for initializing a random number generator.
            </summary>
            <remarks>
            This is not cryptographically secure.
            </remarks>
        </member>
        <member name="P:Lidgren.Network.NetUtility.Now">
            <summary>
            Return a stopwatch for the current time.
            </summary>
            <remarks>
            Values represent seconds since the stopwatch started timing.
            </remarks>
        </member>
        <member name="T:Lidgren.Network.NetSocketAddress">
            <summary>
            Represents an internet socket address, either IPv4 or IPv6.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute">
            <summary>
            Indicates that an API is experimental and it may change in the future.
            </summary>
            <remarks>
            This attribute allows call sites to be flagged with a diagnostic that indicates that an experimental
            feature is used. Authors can use this attribute to ship preview features in their assemblies.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute"/> class,
            specifying the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <param name="diagnosticId">The ID that the compiler will use when reporting a use of the API the attribute applies to.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.DiagnosticId">
            <summary>
            Gets the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <value>The unique diagnostic ID.</value>
            <remarks>
            The diagnostic ID is shown in build output for warnings and errors.
            <para>This property represents the unique ID that can be used to suppress the warnings or errors, if needed.</para>
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.UrlFormat">
            <summary>
            Gets or sets the URL for corresponding documentation.
            The API accepts a format string instead of an actual URL, creating a generic URL that includes the diagnostic ID.
            </summary>
            <value>The format string that represents a URL to corresponding documentation.</value>
            <remarks>An example format string is <c>https://contoso.com/obsoletion-warnings/{0}</c>.</remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field and property members have not-null values.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes the attribute with a field or property member.
            </summary>
            <param name="member">The field or property member that is promised to be not-null.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>
            Initializes the attribute with the list of field and property members.
            </summary>
            <param name="members">The list of field and property members that are promised to be not-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>
            Gets field or property member names.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field and property
            members have not-null values when returning with the specified return value condition.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes the attribute with the specified return value condition and a field or property member.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
            <param name="member">The field or property member that is promised to be not-null.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>
            Initializes the attribute with the specified return value condition and list of field and property members.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
            <param name="members">The list of field and property members that are promised to be not-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>
            Gets the return value condition.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>
            Gets field or property member names.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type,
            and callers do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute">
            <summary>
            Specifies the syntax used in a string.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String)">
            <summary>
            Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.
            </summary>
            <param name="syntax">The syntax identifier.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String,System.Object[])">
            <summary>Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.</summary>
            <param name="syntax">The syntax identifier.</param>
            <param name="arguments">Optional arguments associated with the specific syntax employed.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Syntax">
            <summary>Gets the identifier of the syntax used.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Arguments">
            <summary>Optional arguments associated with the specific syntax employed.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.CompositeFormat">
            <summary>The syntax identifier for strings containing composite formats for string formatting.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateOnlyFormat">
            <summary>The syntax identifier for strings containing date format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateTimeFormat">
            <summary>The syntax identifier for strings containing date and time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.EnumFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Enum"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.GuidFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Guid"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Json">
            <summary>The syntax identifier for strings containing JavaScript Object Notation (JSON).</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.NumericFormat">
            <summary>The syntax identifier for strings containing numeric format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex">
            <summary>The syntax identifier for strings containing regular expressions.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeOnlyFormat">
            <summary>The syntax identifier for strings containing time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeSpanFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.TimeSpan"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Uri">
            <summary>The syntax identifier for strings containing URIs.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Xml">
            <summary>The syntax identifier for strings containing XML.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute">
            <summary>
            Used to indicate a byref escapes and is not scoped.
            </summary>
            <remarks>
            <para>
            There are several cases where the C# compiler treats a <see langword="ref"/> as implicitly
            <see langword="scoped"/> - where the compiler does not allow the <see langword="ref"/> to escape the method.
            </para>
            <para>
            For example:
            <list type="number">
                <item><see langword="this"/> for <see langword="struct"/> instance methods.</item>
                <item><see langword="ref"/> parameters that refer to <see langword="ref"/> <see langword="struct"/> types.</item>
                <item><see langword="out"/> parameters.</item>
            </list>
            </para>
            <para>
            This attribute is used in those instances where the <see langword="ref"/> should be allowed to escape.
            </para>
            <para>
            Applying this attribute, in any form, has impact on consumers of the applicable API. It is necessary for
            API authors to understand the lifetime implications of applying this attribute and how it may impact their users.
            </para>
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>
            An attribute that allows parameters to receive the expression of other parameters.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute"/> class.
            </summary>
            <param name="parameterName">The condition parameter value.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.ParameterName">
            <summary>
            Gets the parameter name the expression is retrieved from.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CollectionBuilderAttribute.#ctor(System.Type,System.String)">
            <summary>
            Initialize the attribute to refer to the <paramref name="methodName"/> method on the <paramref name="builderType"/> type.
            </summary>
            <param name="builderType">The type of the builder to use to construct the collection.</param>
            <param name="methodName">The name of the method on the builder to use to construct the collection.</param>
            <remarks>
            <paramref name="methodName"/> must refer to a static method that accepts a single parameter of
            type <see cref="T:System.ReadOnlySpan`1"/> and returns an instance of the collection being built containing
            a copy of the data from that span.  In future releases of .NET, additional patterns may be supported.
            </remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.BuilderType">
            <summary>
            Gets the type of the builder to use to construct the collection.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.MethodName">
            <summary>
            Gets the name of the method on the builder to use to construct the collection.
            </summary>
            <remarks>
            This should match the metadata name of the target method.
            For example, this might be ".ctor" if targeting the type's constructor.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute"/> type.
            </summary>
            <param name="featureName">The name of the feature to indicate.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>
            The name of the compiler feature.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            If true, the compiler can choose to allow access to the location where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>
            Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>
            Gets the names of the arguments that should be passed to the handler.
            </summary>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>
            Indicates the attributed type is to be used as an interpolated string handler.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
             <summary>
             Used to indicate to the compiler that a method should be called
             in its containing module's initializer.
             </summary>
             <remarks>
             When one or more valid methods
             with this attribute are found in a compilation, the compiler will
             emit a module initializer which calls each of the attributed methods.
            
             Certain requirements are imposed on any method targeted with this attribute:
             - The method must be `static`.
             - The method must be an ordinary member method, as opposed to a property accessor, constructor, local function, etc.
             - The method must be parameterless.
             - The method must return `void`.
             - The method must not be generic or be contained in a generic type.
             - The method's effective accessibility must be `internal` or `public`.
            
             The specification for module initializers in the .NET runtime can be found here:
             https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer
             </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>
            Specifies that a type has required members or that a member is required.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiresLocationAttribute">
            <summary>
            Reserved for use by a compiler for tracking metadata.
            This attribute should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.SkipLocalsInitAttribute">
            <summary>
            Used to indicate to the compiler that the <c>.locals init</c> flag should not be set in method headers.
            </summary>
        </member>
        <member name="M:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class.
            </summary>
        </member>
        <member name="M:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class with the specified message.
            </summary>
            <param name="message">An optional message associated with this attribute instance.</param>
        </member>
        <member name="P:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.Message">
            <summary>
            Returns the optional message associated with this attribute instance.
            </summary>
        </member>
        <member name="P:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.Url">
            <summary>
            Returns the optional URL associated with this attribute instance.
            </summary>
        </member>
    </members>
</doc>
